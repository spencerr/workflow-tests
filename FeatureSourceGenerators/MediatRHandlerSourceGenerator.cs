using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Reflection.Metadata;
using System.Text;

namespace FeatureSourceGenerators;

[Generator]
public class MediatRHandlerSourceGenerator : IIncrementalGenerator
{
    public const string Attribute = @"
namespace FeatureSourceGenerators
{
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class GenerateMediatorAttribute : System.Attribute
    {
    }
}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "GenerateMediatorAttribute.g.cs", SourceText.From(Attribute, Encoding.UTF8)));

        var validationTypes = context.SyntaxProvider
            .CreateSyntaxProvider(CouldBeMediatorClassAsync, GetMediatorClassOrNull)
            .Where(type => type is not null)
            .Collect();

        context.RegisterSourceOutput(validationTypes, GenerateCode);
    }

    private static bool CouldBeMediatorClassAsync(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        if (syntaxNode is not AttributeSyntax attribute)
            return false;

        var name = ExtractName(attribute.Name);

        return name is "GenerateMediator" or "GenerateMediatorAttribute";
    }

    private static string? ExtractName(NameSyntax? name)
    {
        return name switch
        {
            SimpleNameSyntax ins => ins.Identifier.Text,
            QualifiedNameSyntax qns => qns.Right.Identifier.Text,
            _ => null
        };
    }

    private static ITypeSymbol? GetMediatorClassOrNull(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var attributeSyntax = (AttributeSyntax) context.Node;

        // "attribute.Parent" is "AttributeListSyntax"
        // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
        if (attributeSyntax.Parent?.Parent is not ClassDeclarationSyntax classDeclaration)
            return null;

        var type = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as ITypeSymbol;
        return type;
    }

    private static void GenerateCode(SourceProductionContext context, ImmutableArray<ITypeSymbol> enumerations)
    {
        if (enumerations.IsDefaultOrEmpty)
            return;

        foreach (var type in enumerations)
        {
            var code = GenerateCode(type);
            var typeNamespace = type.ContainingNamespace.IsGlobalNamespace
                   ? null
                   : $"{type.ContainingNamespace}.";

            context.AddSource($"{typeNamespace}{type.Name}.g.cs", code);
        }
    }

    private static string GenerateCode(ITypeSymbol type)
    {
        var @namespace = type.ContainingNamespace.IsGlobalNamespace
            ? null
            : type.ContainingNamespace.ToString();

        var wrapperClassName = type.Name;

        var builder = new StringBuilder();
        builder.Append($@"// <auto-generated />
using System.Collections.Generic;

{(@namespace is null ? null : $@"namespace {@namespace};")}
public static partial class {wrapperClassName}
{{
");

        var methods = type.GetMembers().Where(m => m is IMethodSymbol).ToArray();

        var taskType = typeof(Task).FullName;
        var cancellationTokenType = typeof(CancellationToken).FullName;
        foreach (var method in methods.Cast<IMethodSymbol>())
        {
            var requestType = method.Parameters.First();

            var returnType = method.ReturnType.ToDisplayString();
            var responseType = returnType;
            var isUnitType = returnType == taskType;
            if (isUnitType)
            {
                responseType = "MediatR.Unit";
                returnType = "System.Threading.Tasks.Task<MediatR.Unit>";
            }

            if (method.ReturnType is INamedTypeSymbol namedTypeSymbol && namedTypeSymbol.IsGenericType)
            {
                if (namedTypeSymbol.MetadataName == typeof(Task<>).FullName)
                {
                    responseType = namedTypeSymbol.TypeParameters.First().ToDisplayString();
                }
            }

            var validParameters = method.Parameters.Skip(1).Where(p => p.Type.Name != cancellationTokenType).ToArray();
            var record = requestType.Type.IsRecord ? "record" : "class";

            builder.Append($@"
    public sealed partial {record} {requestType.Type.Name} : MediatR.IRequest<{responseType}>{{}}
    
    internal sealed partial class {method.Name}Impl : MediatR.IRequestHandler<{requestType.Type.Name}, {responseType}>
    {{
        {string.Join("\n        ", validParameters.Select(p => $"private readonly {p.Type} _{p.Name};"))}

        public {method.Name}Impl(
            {string.Join(",\n            ", validParameters.Select(p => $"{p.Type} {p.Name}"))}
        )
        {{
            {string.Join("\n            ", validParameters.Select(p => $"_{p.Name} = {p.Name};"))}
        }}

        public async {returnType} Handle({requestType.Type.Name} request, CancellationToken cancellationToken) 
        {{");

            if (isUnitType)
            {
                builder.Append($@"
            await {method.Name}(
                request,
                {string.Join(",\n                ", validParameters.Select(p => $"_{p.Name}"))}
            );
            return MediatR.Unit.Value;");
            } 
            else
            {
                builder.Append($@"
            return await {method.Name}(
                request,
                {string.Join(",\n                ", validParameters.Select(p => $"_{p.Name}"))}             
            );");
            }
            builder.Append($@"
        }}
    }}
");
        }

        var requestClass = type.GetMembers().Where(m => m is ITypeSymbol).ToArray();
        foreach (var @class in requestClass.Cast<ITypeSymbol>())
        {
            var addValidationMethod = @class.GetMembers().OfType<IMethodSymbol>().FirstOrDefault(m => m.Name == "AddValidation");
            if (addValidationMethod is null)
                continue;

            var record = @class.IsRecord ? "record" : "class";

            builder.Append($@"
    public sealed partial {record} {@class.Name}
    {{
        internal sealed partial class Validator : FluentValidation.AbstractValidator<{@class.Name}>
        {{
            public Validator() 
            {{
                {@class.Name}.AddValidation(this);
            }}
        }}
    }}
}}");
        }

        return builder.ToString();
    }
}
